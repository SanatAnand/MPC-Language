// This is a variant of IPS (which may not be secure) but illustrates the syntax.


protocol IPS (int nClnts, int nSrvrs, int sp, field F, 
				(protocol outer(int nC, int nS, int sp, field F) : party C[nC], S[nS]),
				(protocol inner(int n, int index, int sp, field F) : party P[n]) )
				: party C[nClnts] {
	// sp is the security parameter.
	// protocol inner implements (i.e., has a local party for)
	// index-th server in protocol outer

	// watchlist protocol
	uses protocol watchlist (int nC, int nS, int sp, field F) : party P[nC],
			in each P[] {inport WLin[nS][nC], outport WLout[nS][nC][nC]}; 
	// P[i] in wrapinner for server s:
	// 	reports msgs from P[j] on WLin[s][j], 
	//	         and randomness, followed by environ msgs on WLin[s][i]
	// 	reads msgs from P[k] to P[j] on WLout[s][j][k], 
	//         and P[j]'s randomness/environ msgs on WLout[s][j][j]
	//			(WLout[s][i][] unused)


	// ports declared in a protocol are in addition to the default (duplex) ports
	// environ and random for every party
	protocol wrapinner (int nC, int nS, int index) : party R[nC],
		in each R[] {outport Wout[nC], inport Win[nC][nC]} {

		// R[i] reports message received from inner::P[j] on Wout[j] (Wout[i] used to report randomness).
		// and reads messages received by P[j] from P[k] on Win[j][k] (if channel is open)
		// Status of channel, followed by random-tape, and then env messages are read from Win[j][j]

		in each R[#i] {

			party Q[nC]; // parties of inner protocol. Q[i] is the real one.
			for each Q[#j]
				set party Q[j] as inner(n,index)::P[j];
			Q[i]|random => Wout[i];

			bool status[nC];
			for each status[#j] {
				Win[j][j] => status[j];
				if (status[j]) {
					Win[j][j] => Q[j]|random;
					connect Win[j][j] to Q[j]|environ;
					for each Q[#k] except k from {i,j}
						connect Win[j][k] to Q[j]|P[k];
				}
			}

			wrap Q[i] {
				connect @|environ to environ; // this could be outside the wrap block too

				before @|environ => @ {
					forward environ to { Wout[i], @|environ };
				}

				after each @ => @|P[#j] {
					forward @|P[j] to { |R[j], Q[j]|P[i] };
				}

				before each @|P[#j] => @ {
					if (status[j]) {
						// update Q[j] and read from it
						forward Win[j][j] to Q[j]|environ;
						for each win of Win[j][#k]
							forward win to Q[j]|P[k];
						Q[j]|P[i] => unknown x;
						R[j] => unknown y;
						if (x!=y)
							abort;
						x => @|P[j];
						x => @|Wout[j];
					}
				}
			}
		}
	}
	

	session I[nSrvrs];
	for each I[#s]
		open I[s] as wrpinner(nClnts,s,sp,F) {
			P[]:C[];
		}
	

	//watchlist
	open session W as watchlist(nClnts,nSrvrs,sp,F) {
		P[]:C[];
	}

	// connect wrpinner ports to watchlist
	for each I[#s]
		in each P[#i] {
			for each wout of I[s].Wout[#j]
				connect wout to W.@|WLin[s][j];
			for each win of I[s].Win[#j][#k]
				connect W.@|WLout[s][j][k] to win;
		}

	partial open session Out as outer(nClnts,nSrvrs,sp,F) {
		Clnt[]:C[];
	}

	in each C[#i]
		for each outer::Srvr[#s]
			connect Out.Clnt[i]|Srvr[s] and I[s].@|environ;

	in each C[#i]
		connect environ and Out.@|environ;
}
