% Grammar rules ----------------------------------------------
% Comma separted variables are treated aliases
% embed
% {{ tex
% \makeatletter
% \makeatother
% \title{Implementing the add() protocol}
% \author{John Doe}
% \maketitle

% \section{Introduction}
% In the following we 

% }}
metavar A, B ::=
	{{ com Names of parties A, B }}
metavar P ::=
	{{ com Protocol name [[P]] }} {{ tex \wp }}
metavar x, y, s ::=
	{{ com Variables Eg. Session or Integer variables. }}
metavar env ::=
	{{ com Special environment variable [[env]] }}

grammar
tau {{ tex \tau }} :: 'type_' ::= {{ com Types }}
    | Party :: :: party 
    | Int :: :: int
    | Bool :: :: bool
    | Session ::  :: session
    | Port :: :: port
    | Field :: :: field
    | Protocol :: :: protocol
    | () :: :: wellTyped {{ com Well typed }}
    
program :: 'prog_' ::=
	| prtcl :: :: Program
	{{ tex [[prtcl]]^+ }}
	{{ com One or more protocols }}

prtcl :: 'prtcl_' ::=
	 | protocol P ( tau   x ) : party A { statement } :: :: dec
	 {{ tex \textbf{protocol} \ [[P]] ( ([[tau]] \ [[x]])^{+} ) \ \textbf{: party } [[A]]^+
	    \{ \ [[statement]]^+ \ \} }}

terminals :: 'terminals_' ::=
	  | => :: :: leadsto {{ tex \Rightarrow }}
	  | I :: :: I {{ tex \Vert }}
	  | |-              :: :: turnstile    {{ tex \vdash }}
	  | in :: :: in {{ tex \in }}
	  | notin :: :: notin {{ tex \notin }}

constant, c :: CONST_ ::=
	  | integer_literal :: :: int
	  | true :: ::  bool_t
	  | false :: :: bool_f
	  
statement, stmt :: 'statement_' ::= {{ com Statements }}
	  | in A { statement } :: :: pvtstmt
	  {{ tex \textbf{in } [[A]] \ \{ \ [[statement]]^+ \ \} }} {{ com Private statement }}
	  | tau  x ; :: :: declstmt
	  {{ com Declare a variable }}
	  | env => x ; :: :: env_protocol_frwdstmt
	  {{ com Forward from env to var }}
	  | x => env ; :: :: protocol_env_frwdstmt
	  {{ com Forward from var to env}}
	  | x = exp ; :: :: assignsttm
	  {{ com Assignment }}
	  | open  s  as  P ( x ) { ( A : B ) } :: :: opensessionstmt
	  {{ tex \textbf{open} \ [[s]] \ \textbf{as } [[P]] ( [[x]] ) \ \{ \ ([[A]]:[[B]])^+ \ \} }}
	  {{ com Open session [[s]] }}
	  | set A as P ( x ) B :: :: setstmt
	  {{ tex \textbf{set} \ [[A]] \ \textbf{as} \ [[P]] ( [[x]]^* ) \ \textbf{::} \ [[B]] }}
	  {{ com Set party as another party of another protocol }}
  	  | exp => exp' :: :: exp_exp_frwdstmt
	  {{ com Forward from a exp to exp }}
	  | wrap { wstmt } :: :: wrapstmt
	  {{ tex \textbf{wrap} \ \{ [[wstmt]]^+ \} }}
	  {{ com Wrap statement }}
	  % | forward pexp to pexp' :: :: fwd_to
	  % {{ tex \textbf{forward} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
	  | connect pexp and pexp' :: ::  connect_and
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{and} \ [[pexp']] }}
	  {{ com Duplex connection }}
  	  | connect pexp to pexp' :: ::  connect_to
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
  	  {{ com One way connection }}

wstmt {{ tex \mathcal{W}_{stmt} }} :: 'wstmt_' ::= {{ com Statements inside wrap  }}
	  | before pexp_w do { statement } :: :: bef
	  {{ tex \textbf{before} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}
  	  | after pexp_w do { statement } :: :: after
	  {{ tex \textbf{after} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}

pexp_w {{ tex pexp_{w} }} :: 'pexp_w_' ::=
	  % | env I A :: :: env_to_party
	  | A I env :: :: party_to_env 

pexp {{ tex \mathcal{P}_{exp} }} :: 'pexp_' ::=
     | env :: :: env {{ com environment }}
     | A I B :: :: twoparties {{ com Two parties }}
     | s.A I env :: :: sessionParty_env {{ com env of Party of session }} 
     | pexp_w :: :: pexp_w
     | A :: :: party {{ com Party }}
     % | x :: :: var {{ com Variable }}
     % | A I env :: :: partys_env {{ com env port of a party called A }}

exp :: 'expr_' ::=
    | exp + exp' :: :: addition {{ com Addition of two Int }}
    | A.x :: :: party_var {{ com Variable of a party A }}


Tenv {{ tex T }} :: 'TypeEnv' ::= {{ com Type environment }}
  | empty :: :: em {{ tex \epsilon }} {{ com Empty }}
  | Tenv , G : tau  :: ::  global_scope
  % | M :: :: protocol_scope  {{ tex \mathcal{M} }} {{ com Protocol Scope }}
  % | rho :: :: party_scope {{ tex \rho }} {{ com Protocl, Party Scope }}
  % | sesn :: :: session_scope {{ tex \mathcal{S} }} {{ com Session Scope }}
  % | G , M , rho , S : tau  :: :: typ {{ tex G, \  M, \ \rho, \ \mathcal{S} : [[tau]] }}

formula :: 'formula_' ::=
	| judgement :: :: judgement
	| env : tau :: :: env_type
	| Tenv |- P : tau :: :: protcol_type
	| pexp : tau :: :: party_type
	| pexp : tau in Tenv :: :: pexp_in_tenv
	| Tenv |- pexp : tau :: :: pexptype
	| x : tau in Tenv :: :: exists
	| x : tau notin Tenv :: :: doesnotexist
	| Tenv |- x : tau :: :: x_type
	% | Tenv |- protocol : tau :: :: protocol


% Type Checking rules ----------------------------------------------
defns
  Jtype :: '' ::=

  defn
	Tenv |- constant : tau :: ::  Constant :: Constant_ by

	------------------------------ :: Int
	Tenv |- integer_literal : Int

	------------------------------ :: true
	Tenv |- true : Bool

	------------------------------ :: false
	Tenv |- false : Bool

 defn 	
	Tenv |- stmt : tau :: :: Stmt :: Stmt_ by

	       A : Party in Tenv
             Tenv |- statement : ()
	------------------------------- :: pvt
	Tenv , G |- in A { statement } : ()

	      x : tau notin Tenv
	------------------------------------- :: decl
		Tenv |- tau x ; : tau
		
	     Tenv |- env : ()
	     Tenv |- x : tau
	 ------------------------------- :: fwd
	    Tenv |- env => x; : tau

	       Tenv |- x : tau
	      Tenv |- exp : tau
	 ------------------------------ ::  assignmnt
	 Tenv |- x = exp; : tau

	     Tenv |- x : tau 
	     Tenv |- s : Session
	     Tenv |- P : Protocol
	     Tenv |- A : Party
	     Tenv |- B : Party
	 ------------------------------ :: opensession
	 Tenv |- open s as P ( x ) { ( A : B ) } : ()

	      Tenv |- A : Party
	      Tenv |- B : Party
	      Tenv |- P : Protocol
	      Tenv |- x : tau
	 ------------------------------- :: set
	 Tenv |- set A as P ( x ) B : ()

	      Tenv |- exp : tau
	      Tenv |- exp' : tau
	 ------------------------------- :: fwdExprToExpr
	  Tenv |- exp => exp' : tau

 
	 -------------------------------- :: wrap
	       Tenv |- wrap { wstmt } : ()

	%      	Tenv |- pexp : tau
	% 	Tenv |- pexp' : tau
	% ---------------------------------------------- :: fwdto
	% Tenv |- forward pexp to pexp' : tau

	     	Tenv |- pexp : tau
		Tenv |- pexp' : tau
	---------------------------------------------- :: connectTo
	Tenv |- connect pexp to pexp' : tau

	     	Tenv |- pexp : tau
		Tenv |- pexp' : tau
	---------------------------------------------- :: connectAnd
	Tenv |- connect pexp and pexp' : tau

defn Tenv |- wstmt : tau :: :: Wrapstmt :: Wrapstmt_ by

     	       Tenv |- pexp_w : Port
	       Tenv |- statement : tau
	---------------------------------------------- :: before
	Tenv |- before pexp_w do { statement } : tau

       	       Tenv |- pexp_w : Port	
	       Tenv |- statement : tau
	---------------------------------------------- :: after
	Tenv |- after pexp_w do { statement } : tau

defn   Tenv |- prtcl : tau :: :: Protocol :: Protocol_  by

       	       Tenv |- P : Protocol
	       Tenv |- x_1 : tau_1
	       Tenv |- x_2 : tau_2
	       Tenv |- x_3 : tau_3
	       Tenv |- A : Party
	       Tenv |- statement : tau
	----------------------------------------------- :: decl
	Tenv |- protocol P ( tau   x ) : party A { statement } : tau
defn
	Tenv |- exp : tau :: :: Exp :: Exp_ by

	Tenv |- exp : Int
	Tenv |- exp' : Int
	-------------------------------- :: Addition
	Tenv |- exp + exp' : Int

		x : tau in Tenv
		Tenv |- A : Party 
	------------------------------ :: PartyVar
		Tenv |- A.x : tau

% Opertional Semantics rules ----------------------------------------------
defns
  Jop :: '' ::=