% Grammar rules ----------------------------------------------
% Comma separted variables are treated aliases
indexvar n , m , k , i , j ::=
	 {{ com Index variables }}
metavar A , B ::=
	{{ com Names of parties A , B }}
metavar P , Q ::=
	{{ com Protocol name [[P]] }} 
metavar x, y, s ::=
	{{ com Variables Eg. Session, Party,  Integer variables. }}
metavar r ::=
	{{ com Port types }} {{ tex \pi }}
metavar env ::=
	{{ com Special environment variable [[env]] denoting a port type}}
metavar O ::=
	{{ com Port names [[O]] }}
metavar G ::= 
	
metavar M ::= 

metavar R ::=

metavar L ::=

metavar S ::= 



grammar
tau {{ tex \tau }} :: 'type_' ::= {{ com Types }}
    | Party :: :: party 
    | Int :: :: int
    | Bool :: :: bool
    | Session ::  :: session
    | Port :: :: port
    | Field :: :: field
    | Protocol :: :: protocol
    | unknown :: :: unknwn 
    | () :: :: wellTyped {{ com unit type }}
    | _ :: :: donotcare {{ com don't care }}

constant, c :: CONST_ ::=
	  | integer_literal :: :: int
	  | true :: ::  bool_t
	  | false :: :: bool_f
	  | env :: :: port_type
	  
program :: 'prog_' ::=
	| prtcl1 , .. , prtcln :: :: Program
	% {{ tex [[prtcl]]^+ }}
	{{ com one or more protocols }}

prtcl :: 'prtcl_' ::=
       |protocol P ( tau1 x1 , .. , taun xn ( prtcl' ) ) : party A1 , .. , Am each with { Port x1' , .. , Port xi' } { stmt } :: :: prtcldec
	 % {{ tex \textbf{protocol} \ [[P]] ( ([[tau]] \ [[x]])^{+} ) \ \textbf{: party } [[A]]^+
	    % \{ \ [[statement]]^+ \ \} }}
	{{ com Protocol }}

terminals :: 'terminals_' ::=
	  | => :: :: leadsto {{ tex \Rightarrow }}
	  | -> :: :: longrightarrow {{ tex \longrightarrow }}
	  | I :: :: I {{ tex \Vert }}
	  | |-              :: :: turnstile    {{ tex \vdash }}
	  | belongsto :: :: in {{ tex \in }}
	  | notin :: :: notin {{ tex \notin }}
	  | != :: :: noteq {{ tex \neq }}
	  
statement, stmt :: 'statement_' ::= {{ com Statements }}
	  | in each A1 , .. , Am { stmt1 , .. , stmtn } :: :: pvtstmt % TODO: bind stmt to in A
	  | tau  x ; :: :: declstmt
	  {{ com Declare a variable }}
	  | statement ; statement' ; :: :: seq
	  {{ com Sequence of statements }}
	  | env => x ; :: :: env_protocol_sendstmt
	  {{ com Send from environment to a variable }}
	  | x => env ; :: :: protocol_env_sendstmt
	  {{ com Send from a variable to environment }}
  	  | exp => exp' :: :: exp_exp_sendstmt
	  {{ com Send from an expression to another expression }}
	  | x = exp ; :: :: assignsttm
	  {{ com Assign to a variable }}
	  | open  s  as  P ( x1 , .. , xn ) { A1 : B1 , .. , Am : Bm } :: :: opensessionstmt
	  % {{ tex \textbf{open} \ [[s]] \ \textbf{as } [[P]] ( [[x]] ) \ \{ \ ([[A]]:[[B]])^+ \ \} }}
	  {{ com Open a session called [[s]] }}
	  | set A as P ( x1 , .. , xn ):: B :: :: setstmt
	  % {{ tex \textbf{set} \ [[A]] \ \textbf{as} \ [[P]] ( [[x]]^* ) \ \textbf{::} \ [[B]] }}
	  {{ com Set party [[A]] as another party [[B]] of another protocol [[P]] }}
	  | wrap { wstmt } :: :: wrapstmt
	  {{ tex \textbf{wrap} \ \{ [[wstmt]]^+ \} }}
	  {{ com Wrap some statements and perform some checks before or after doing something }}
	  % | forward pexp to pexp' :: :: fwd_to
	  % {{ tex \textbf{forward} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
	  | connect pexp and pexp' :: ::  connect_and
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{and} \ [[pexp']] }}
	  {{ com Duplex connection between two ports }}
  	  | connect pexp to pexp' :: ::  connect_to
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
  	  {{ com One way connection between two ports }}


wstmt {{ tex \mathcal{W}_{stmt} }} :: 'wstmt_' ::= {{ com Statements inside wrap  }}
	  | before pexp do { statement1 , .. , statementn } :: :: bef
	  % {{ tex \textbf{before} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}
  	  | after pexp do { statement1 , .. , statementn } :: :: after
	  % {{ tex \textbf{after} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}

pexp {{ tex \mathcal{P}_{exp} }} :: 'pexp_' ::=
     | A I r :: :: env {{ com Port of a Party }}
     | A I B :: :: twoparties {{ com Port of another Party }}
     | s . A I r :: :: sessionParty_env {{ com Port [[r]] of a Party [[A]] that belongs to session [[s]] }} 
     % | A :: :: party {{ com Party }}
     % | x :: :: var {{ com Variable }}
     % | A I env :: :: partys_env {{ com env port of a party called A }}

exp :: 'expr_' ::=
    | exp + exp' :: :: addition {{ com Addition of two expresions }}
    | A . x :: :: party_var {{ com Variable [[x]] of a party [[A]] }}
    % | s . A :: :: vart_party {{ com Party [[A]] of a variable [[s]] }}
    | x :: :: statement {{ com Expression statement }}

scope :: 'scope_' ::=
     | C :: ::  current_scop {{ com Current Scope }} {{ tex \mathcal{C} }}
     | _ :: :: dont_care_scop {{ com Do not care }}
     | W :: :: global_scop {{ com Global Scope }} {{ tex \mathcal{G} }}
     | A :: :: party_scop {{ com Party Scope for statements like in A \{ .. \} }}
    

Tenv {{ tex \mathcal{E} }} :: 'TypeEnv' ::= {{ com Type environment }}
  | empty :: :: em {{ tex \phi }} {{ com Empty Type enviornment }}
  | G :: :: id_to_type_scope
  {{ com A function that takes a variable name and returns its type and scope }}
  | M :: :: prtcl_to_arglist_partynmlist
  {{ com A function that takes a protocol name and returns a tuple ( argsig , Party list ) }}
  | R :: :: prtcl_to_portlist
    {{ com A function that takes a tuple (Protocol name , Party name) and returns list of Ports the party has }} 
  | S :: :: sessn_to_prtcl
  {{ com Maps a session name to the name of a protocol }}
  | L :: :: party_scope_to_portlist
  {{ com Maps ( Party name , Scope ) to the list of ports }}
  | scope :: :: current_scope
  {{ com The current scope of execution }}
  | Tenv , Tenv' :: :: tenv_and_tenv_prime
  {{ com A sequence of Type environments }}
  

  
    % | M :: :: Protocol_Scexp :: 'expr_' ::=ope {{ tex \mathcal{M} }} {{ com Protocol Scope }}

  % | sesn :: :: session_scope {{ tex \mathcal{S} }} {{ com Session Scope }}
  % | G , M , R , S : tau  :: :: typ {{ tex G, \  M, \ \R, \ \mathcal{S} : [[tau]] }}
argsig :: 'argsig_' ::=
       | { tau1 , .. , taun } :: :: type_signature

portlist :: 'prtlist_' ::=
	 | { O1 , .. , On } :: :: port_list


formula :: 'formula_' ::=
	| judgement :: :: judgement
	| formula1 .. formulan :: :: dots
	| env : tau :: :: env_type
	| Tenv :: :: type_env
	| x notin scope :: :: var_not_inscope
	| r belongsto portlist :: :: port_in_portlist
	| B belongsto portlist :: :: partyport_in_portlist
	| x belongsto scope :: :: var_inscope
	|	       portlist = { x'1 , .. , x'i } :: :: initial_portlist
	| P notin scope :: :: prtcl_not_inscope
	| tau belongsto { tau1 , .. , taun } :: :: type_notin_type
	| A belongsto scope :: :: party_inscope
	| Tenv |- stmt : tau :: :: stmt_tenv
	% | Tenv |- wstmt : tau :: :: wstmt_tenv
	| Tenv |- x : tau :: :: var_type
	| Tenv = Tenv' :: :: assign_newenv
	| [ tau1 , .. , taun ] == argsig :: :: types_in_argsig
	| Tenv belongsto { Tenv1 , .. , Tenvn } :: :: tenv_in_tenv
	| Tenv |- pexp : tau :: :: pexp_tenv_tenv
	| G ( formula ) = ( tau , scope )  :: :: PrtckNm_TypeScope
	| G ( formula ) != ( tau , scope ) :: :: PrtckNm_not_TypeScope
        | G' = G [ formula -> ( tau , scope ) ] :: :: introduce_new_var
	| M ( P ) = ( argsig , { A1 , .. , Am } ) :: :: PrtclNm_ArgsigPartyNms
	| M ( P ) != ( argsig , { A1 , .. , Am } ) :: :: PrtclNm_not_ArgsigPartyNms
	| M' = M [ P -> ( argsig , { A1 , .. , Am } ) ] :: :: PrtclNm_ArgsigIntroduce
	| R ( P , A ) = portlist :: :: prtcl_party_TO_portlist
	| R ( P , A ) != portlist :: :: prtcl_party_notTO_portlist
	| R' = R [ ( P , A ) -> portlist ] :: :: prtcl_party_introduction
	| S ( s ) =  P :: :: sessionNm_PrtclNm
	| S ( s ) !=  P :: :: sessionNmNOT_PrtclNm
	| S' = S [ s -> P ] :: :: sessionNm_intro
	| L ( A , scope ) = portlist :: :: partynm_scopelist_TO_portlist
	| L ( A , scope ) != portlist :: :: partynm_scopelist_noTO_portlist
	| L' = L [ ( A , scope ) -> portlist ] :: :: partynm_scopelist_intro
	| P belongsto dom Tenv :: :: form_in_domain_fom
	| P notin dom Tenv :: :: form_notin_domain_fom
	| ( P , A ) belongsto dom Tenv :: :: prtclparty_in_domain_fom
	| A :: :: party_env
	| x :: :: var_env
	| P :: :: prtcl_env
	| scope :: :: scop

% Type Checking rules ----------------------------------------------
defns
  Jtype :: '' ::= 
  
  % Type checking constants
  defn
	Tenv |- constant : tau :: ::  Constant :: Constant_ {{ com Checking constants }} by

	------------------------------ :: Int
	G , M , R , S , L , C|- integer_literal : Int

	------------------------------ :: true
	G , M , R , S , L , C|- true : Bool

	------------------------------ :: false
	G , M , R , S , L , C|- false : Bool
	
 % Type checking Statements
  defn 	Tenv |- stmt : tau , Tenv' :: :: Stmt :: Stmt_ by

  	     	G ( x ) != ( _ , C )
		G' = G [ x -> ( tau , C ) ]
		% TODO: see how we change R here
	------------------------------------------------------ :: decl
	G , M , R , S , L, C |- tau x ; : () , G' , M , R , S , L , C 

	G , M , R , S , L , _ |- statement : () , G' , M , R , S' , L'
	G' , M , R , S' , L' , _ |- statement' : () , G'' , M , R , S'' , L''
	----------------------------------------------------- :: seq
	G , M , R , S , L , _ |- statement ; statement' ; : () , G'' , M , R , S'' , L'' , _
		
	     G ( A1 ) = ( Party , _ )
	     G , M , R , S , L , A1 |- stmt1 : () , G' , M , R , S' , L'
	     G' , M , R , S' , L' , A1 |- stmtn : () , G'' , M , R , S'' , L''
	     G ( Am ) = ( Party , _ )
	     G'' , M , R , S'' , L'' , Am |- stmt1 : () , G''' , M , R , S''' , L'''
	     G''' , M , R , S''' , L''' , Am |- stmtn : () , G'''' , M , R , S'''' , L''''
	---------------------------------------------------------------------------------------- :: pvt
	G , M , R , S , L , C |- in each A1 , .. , Am { stmt1 , .. , stmtn } : () , G'''' , M , R , S'''' , L'''' , C 

	     G ( x ) = ( Int , C )
	 ------------------------------- :: sendEnvToVar
	    G , M , R , S , L , C |- env => x; : () , G , M , R , S , L , C 

	     G ( x ) = ( Int , C )
	 ------------------------------- :: sendVarToEnv
	    G , M , R , S , L , C |- x => env; : () , G , M , R , S , L , C 

	      G , M , R , S , L , C|- exp : tau
	      G , M , R , S , L , C|- exp' : tau'
	      tau belongsto { Port , Int , Bool , unknown }
	      tau' belongsto { Port , Int , Bool , unknown }
	 ---------------------------------------------------------------- :: sendExprToExpr
	      G , M , R , S , L , C|- exp => exp' : () , G , M , R , S , L , C 

	       G ( x ) = ( tau , C )
	       G , M , R , S , L , C |- exp : tau
	 ---------------------------------------------------------------- ::  assignmnt
	     G , M , R , S , L , C|- x = exp; : () , G , M , R , S , L , C 

	 G ( s ) = ( Session , C )
	 P belongsto dom M 
 	 M ( P ) = ( argsig , { A1 , .. , Am } )
	 G ( x1 ) = ( tau1 , C)
	 G ( xn ) = ( taun , C)
	 [ tau1 , .. , taun ] == argsig
	 G ( B1 ) = ( Party , C )
	 G ( Bm ) = ( Party , C )
	 S' = S [ s -> P ]
------------------------------------------------------------------------------------- :: openSession
 G , M , R , S , L , C|- open  s  as  P ( x1 , .. , xn ) { A1 : B1 , .. , Am : Bm } : () , G , M , R , S' , C 

	   G ( A ) = ( Party , C )
	   P belongsto dom M 
	   G ( x1 ) = ( tau1 , _ )
	   G ( xn ) = ( taun , _ )
	   M ( P ) = ( argsig , { A1 , .. , Am } )
	   B belongsto { A1 , .. , Am }
	   [ tau1 , .. , taun ] == argsig
	   ( P , B ) belongsto dom R
	   R ( P , B ) = portlist
	   L' = L [ ( A , C ) -> portlist ]
	 ------------------------------- :: set
	 G , M , R , S , L , C |- set A as P ( x1 , .. , xn )::B : () , G , M , R , S , L' , C 
         
	    G , M , R , S , L , C |- wstmt : () , G' , M , R , S' , L' 
	    G' , M , R , S' , L' , C |- wstmt : () , G'' , M , R , S'' , L'' 
	-------------------------------- :: wrap
	  G , M , R , S , L , C|- wrap { wstmt } : () , G'' , M , R , S'' , L'' , C 

	     	G , M , R , S , L , C|- pexp : Port
		G , M , R , S , L , C|- pexp' : Port
	---------------------------------------------- :: connectTo
        G , M , R , S , L , C|- connect pexp to pexp' : () , G , M , R , S , L , C 

	     	G , M , R , S , L , C|- pexp : Port
		G , M , R , S , L , C|- pexp' : Port
	---------------------------------------------- :: connectAnd
        G , M , R , S , L , C|- connect pexp and pexp' : () , G , M , R , S , L , C

	
defn Tenv |- wstmt : tau , Tenv' :: :: Wrapstmt :: Wrapstmt_ by

     	       G , M , R , S , L , C|- pexp : Port
	       G , M , R , S , L , C |- stmt1 : () , G' , M , R , S' , L' 
	       G' , M , R , S' , L' , C |- stmtn : () , G'' , M , R , S'' , L'' 
	    ---------------------------------------------- :: before
	G , M , R , S , L , C|- before pexp do { statement1 , .. , statementn } : () , G'' , M , R , S'' , L'' 

       	       G , M , R , S , L , C|- pexp : Port
	       G , M , R , S , L , C |- stmt1 : () , G' , M , R , S' , L' 
	       G' , M , R , S' , L' , C |- stmtn : () , G'' , M , R , S'' , L'' 
	---------------------------------------------- :: after
	G , M , R , S , L , C|- after pexp do { statement1 , .. , statementn } : () , G'' , M , R , S'' , L'' 

defn   Tenv |- prtcl : tau , Tenv' :: :: Protocol :: Prtcl_  by
  	       P notin dom M
	       G' = G [ P -> ( Protocol , W ) ]
	       G'' = G' [ x1 -> ( tau1 , W ) ]
	       G''' = G'' [ A -> ( Party , W ) ]
	       portlist = { x'1 , .. , x'i }
	       R' = R [ ( P , A ) -> portlist ]
	       M' = M [ P -> ( argsig , { A1 , .. , Am } ) ]
	       G''' , M' , R' , S , L |- prtcl' : () , G''' , M'' , R'' , S , L 
	       G''' , M'' , R'' , S , L , C |- stmt : () , G'''' , M'' , R''' , S''' , L'''
	----------------------------------------------- :: decl
	M , R |- protocol P ( tau1 x1 , .. , taun xn ( prtcl' ) ) : party A each with { Port x1' , .. , Port xi' } { stmt } : () , M' , R'
	
defn	Tenv |- exp : tau :: :: Exp :: Exp_ by

		G , M , R , S , L , C|- exp : tau
		G , M , R , S , L , C|- exp' : tau
	--------------------------------------------- :: Addition
		G , M , R , S , L , C|- exp + exp' : tau


		G ( A ) = ( Party , C )
	        G ( x ) = ( Int , A )
		%tau belongsto { Int}
	--------------------------------------------- :: PartyVar
		G , M , R , S , L , C|- A . x : Int

	% 	G ( s ) = ( Session , _ )
	% 	S ( s ) = P
        %         M ( P ) = ( argsig , { A1 , .. , Am } )	
	% 	A belongsto { A1 , .. , Am }
	% --------------------------------------------- :: VarParty
	% 	G , M , R , S , L , C |- s . A : Party
		
		G ( x ) = ( tau , _ )
	--------------------------------------------- :: Statement
		G , M , R , S , L |- x : tau

defn Tenv |- pexp : tau :: :: Pexp :: Pexp_ by

     	  G ( s ) = ( Session , C )
	  S ( s ) = P
          M ( P ) = ( argsig , { A1 , .. , Am } )
	  A belongsto { A1 , .. , Am }
	  R ( P , A ) = portlist
	  r belongsto portlist
        ----------------------------------------------- :: ExpToEnv
     	  G , M , R , S , L , C |-  s . A I r : Port

                G ( A ) = ( Party , C )
		L ( A , C ) = portlist
		r belongsto portlist
	  ---------------------------------------------- :: PortOfParty
	  G , M , R , S , L , C |- A I r : Port

G ( A ) = ( Party , C )
L ( A , C ) = portlist
B belongsto portlist
---------------------------------------------- :: PortOfAnotherParty
G , M , R , S , L , C |- A I B : Port
	  
		% G , M , R , S , L , C |- 
% Opertional Semantics rules ----------------------------------------------
defns
  Jop :: '' ::=