% Grammar rules ----------------------------------------------
% Comma separted variables are treated aliases
indexvar n , m , k , i , j  , o , e , c ::=
	 {{ com Index variables }}
metavar A , B , D , Z ::=
	{{ com Names of parties A , B }}
metavar P , Q ::=
	{{ com Protocol name [[P]] }} 
metavar x, y, s ::=
	{{ com Variables Eg. Session, Party,  Integer variables. }}
metavar r ::=
	{{ com Port types }}
metavar w ::=
	{{ com Wire variable }}
metavar env ::=
	{{ com Special environment variable [[env]] denoting a port type}}
metavar T ::=
	{{ com Port names [[T]] }}
metavar O ::=
	{{ com Code Object [[O]] }}
metavar G ::= 
	{{ com explained later }}	
metavar M ::= 
	{{ com explained later }}	
metavar R ::=
	{{ com explained later }}	
metavar L ::=
	{{ com explained later }}	
metavar S ::= 
	{{ com explained later }}
metavar E ::= 
	{{ com explained later }}
metavar K ::= 
	{{ com explained later }}

grammar
tau {{ tex \tau }} :: 'type_' ::= {{ com Types }}
    | Party :: :: party 
    | Int :: :: itn
    | Bool :: :: bool
    | Session ::  :: session
    | Port :: :: port {{ com subsumes inport and outport }}
    | Field :: :: field
    | Protocol :: :: protocol
    | unknown :: :: unknwn 
    | () :: :: wellTyped {{ com unit type }}
    | _ :: :: donotcare {{ com don't care }}

 Port :: 'prt_' ::=
      | inport :: :: in_port {{ tex \textcircled{$\downarrow$} }}
       	      {{ com Inport }}
      | outport :: :: out_port  {{ tex \textcircled{$\uparrow$} }}
       	       {{ com outport }}
	
constant :: CONST_ ::=
	  | integer_literal :: :: int
	  | true :: ::  bool_t
	  | false :: :: bool_f
	  | env :: :: port_type
	  
program :: 'prog_' ::=
	 | prtcl1 , .. , prtcln :: :: Program
	% {{ tex [[prtcl]]^+ }}
	{{ com one or more protocols }}

prtcl :: 'prtcl_' ::=
       | protocol P ( tau1 x1 , .. , taun xn ( prtcl' ) ) : party A1 , .. , Am each with { Port1 x1' , .. , Porti xi' } { stmt } :: :: prtcldec
	 % {{ tex \textbf{protocol} \ [[P]] ( ([[tau]] \ [[x]])^{+} ) \ \textbf{: party } [[A]]^+
	    % \{ \ [[statement]]^+ \ \} }}

terminals :: 'terminals_' ::=
	  | => :: :: leadsto {{ tex \Rightarrow }}
	  | -> :: :: longrightarrow {{ tex \longrightarrow }}
	  | <-> :: :: lonlgleftrightarrow {{ tex \longleftrightarrow }}
	  | I :: :: I {{ tex \Vert }}
	  | |-              :: :: turnstile    {{ tex \vdash }}
	  | belongsto :: :: in {{ tex \in }}
	  | notin :: :: notin {{ tex \notin }}
	  | != :: :: noteq {{ tex \neq }}
	  | crt :: :: create {{ tex \underrightarrow{create} }}
	  | apnd :: :: append {{ tex \underrightarrow{append} }}
	  | atch :: :: attach {{ tex \underrightarrow{attach} }}
	  | copy :: :: cpy {{ tex \xLongrightarrow{copycode} }}
	  | replace :: :: replace {{ tex \underrightarrow{replace} }}
	  | < :: :: brack_l {{ tex \langle }}
	  | > :: :: brack_r {{ tex \rangle }}

	  
statement, stmt :: 'statement_' ::= {{ com Statements }}
	  | in each A1 , .. , Am { stmt1 , .. , stmtn } :: :: pvtstmt
	   {{ com Do something in the context of parties }}
	  % TODO: bind stmt to in A
	  | tau  x ; :: :: declstmt
	  {{ com Declare a variable }}
	  | statement ; statement' ; :: :: seq
	  {{ com Sequence of statements }}
	  | env => x ; :: :: env_protocol_sendstmt
	  {{ com Send from environment to a variable }}
	  | x => env ; :: :: protocol_env_sendstmt
	  {{ com Send from a variable to environment }}
  	  | exp => exp' :: :: exp_exp_sendstmt
	  {{ com Send from an expression to another expression }}
	  | x = exp ; :: :: assignsttm
	  {{ com Assign to a variable }}
	  | open  s  as  P ( x1 , .. , xn ) { A1 : B1 , .. , Am : Bm } :: :: opensessionstmt
	  % {{ tex \textbf{open} \ [[s]] \ \textbf{as } [[P]] ( [[x]] ) \ \{ \ ([[A]]:[[B]])^+ \ \} }}
	  {{ com Open a session called [[s]] }}
	  | set A as P ( x1 , .. , xn ):: B :: :: setstmt
	  % {{ tex \textbf{set} \ [[A]] \ \textbf{as} \ [[P]] ( [[x]]^* ) \ \textbf{::} \ [[B]] }}
	  {{ com Set party [[A]] as another party [[B]] of another protocol [[P]] }}
	  | wrap { wstmt } :: :: wrapstmt
	  {{ tex \textbf{wrap} \ \{ [[wstmt]]^+ \} }}
	  {{ com Wrap some statements and perform some checks before or after doing something }}
	  % | forward pexp to pexp' :: :: fwd_to
	  % {{ tex \textbf{forward} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
	  | connect pexp and pexp' :: ::  connect_and
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{and} \ [[pexp']] }}
	  {{ com Duplex connection between two ports }}
  	  | connect pexp to pexp' :: ::  connect_to
	  {{ tex \textbf{connect} \ [[pexp]] \ \textbf{to} \ [[pexp']] }}
  	  {{ com One way connection between two ports }}


wstmt {{ tex \mathcal{W}_{stmt} }} :: 'wstmt_' ::= {{ com Statements inside wrap  }}
	  | before pexp do { statement1 , .. , statementn } :: :: bef
	  % {{ tex \textbf{before} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}
  	  | after pexp do { statement1 , .. , statementn } :: :: after
	  % {{ tex \textbf{after} \ [[pexp_w]] \ \textbf{do} \ \{ [[statement]]^+ \} }}

pexp {{ tex \mathcal{P}_{exp} }} :: 'pexp_' ::=
     | A I r :: :: env {{ com Port of a Party }}
     | A I B :: :: twoparties {{ com Port of another Party }}
     | s . A I r :: :: sessionParty_env {{ com Port [[r]] of a Party [[A]] that belongs to session [[s]] }} 
     % | A :: :: party {{ com Party }}
     % | x :: :: var {{ com Variable }}
     % | A I env :: :: partys_env {{ com env port of a party called A }}

exp :: 'expr_' ::=
    | exp + exp' :: :: addition {{ com Addition of two expresions }}
    | A . x :: :: party_var {{ com Variable [[x]] of a party [[A]] }}
    % | s . A :: :: vart_party {{ com Party [[A]] of a variable [[s]] }}
    | x :: :: statement {{ com Expression statement }}

scope :: 'scope_' ::=
     | C :: ::  current_scop {{ com Current Scope }} {{ tex \mathcal{C} }}
     | _ :: :: dont_care_scop {{ com Do not care }}
     | W :: :: global_scop {{ com Global Scope }} {{ tex \mathcal{G} }}
     | A :: :: party_scop {{ com Party Scope for statements like in A \{ .. \} }}
     | P :: :: protocol_scop {{ com Protocol Scope }}
     | s . A :: :: sessions_party_scp {{ com Sessions Party Scope }}

    

Tenv {{ tex \mathcal{E} }} :: 'TypeEnv' ::= {{ com Type environment }}
  | empty :: :: em {{ tex \phi }} {{ com Empty Type enviornment }}
  | G :: :: id_to_type_scope
  {{ com A function that takes a variable name and returns its type and scope }}
  | M :: :: prtcl_to_arglist_partynmlist
  {{ com A function that takes a protocol name and returns a tuple ( argsig , Party list ) }}
  | R :: :: prtcl_to_portlist
    {{ com Mapping of (Protocol name , Party name) to the list of Ports the party has }} 
  | S :: :: sessn_to_prtcl
  {{ com Maps a session name to the name of a protocol }}
  | L :: :: party_scope_to_portlist
  {{ com Maps ( Party name , Scope ) to the list of ports }}
  | scope :: :: current_scope
  {{ com The current scope of execution }}
  | Tenv , Tenv' :: :: tenv_and_tenv_prime
  {{ com Sequence of Type environments }}

% Compilation environment ------ 
Cenv {{ tex \mathcal{M} }} :: 'CompEnv' ::= {{ com Compilation environment }}
     | empty :: :: emt
     | E :: :: prtcl_party_to_codeObj
     {{ com Maps ( Protocol, Party, PartyScope ) to Code Object }}
     | O < scope > :: :: codeObj
     {{ com Represents code object }}
     | O_c :: :: current_codeObj
     {{ com Represents the current code object }}
     | P :: :: current_prtcl
     {{ com Represents protcol }}
     | K :: :: codeObj_to_ports
     {{ com Maps code objects to list of ports }}
     | Cenv , Cenv' :: :: compenv_seq
     {{ com Sequence of Compilation Environments }}
     | val :: :: value   
    % | M :: :: Protocol_Scexp :: 'expr_' ::=ope {{ tex \mathcal{M} }} {{ com Protocol Scope }}

  % | sesn :: :: session_scope {{ tex \mathcal{S} }} {{ com Session Scope }}
  % | G , M , R , S : tau  :: :: typ {{ tex G, \  M, \ \R, \ \mathcal{S} : [[tau]] }}
argsig :: 'argsig_' ::=
       | { tau1 , .. , taun } :: :: type_signature

portlist :: 'prtlist_' ::=
	 | { T1 , .. , Tn } :: :: port_list


formula :: 'formula_' ::=
       	| judgement :: :: judgement
% ----- For writing type checking rules
	| formula1 .. formulan :: :: dots
	| env : tau :: :: env_type
	| Tenv :: :: type_env
	| x notin scope :: :: var_not_inscope
	| r belongsto portlist :: :: port_in_portlist
	| B belongsto portlist :: :: partyport_in_portlist
	| x belongsto scope :: :: var_inscope
	|	       portlist = { x'1 , .. , x'i } :: :: initial_portlist
	| P notin scope :: :: prtcl_not_inscope
	| tau belongsto { tau1 , .. , taun } :: :: type_notin_type
	| A belongsto scope :: :: party_inscope
	| Tenv |- stmt : tau :: :: stmt_tenv
	| Tenv |- x : tau :: :: var_type
	| Tenv = Tenv' :: :: assign_newenv
	| [ tau1 , .. , taun ] == argsig :: :: types_in_argsig
	| Tenv belongsto { Tenv1 , .. , Tenvn } :: :: tenv_in_tenv
	| Tenv |- pexp : tau :: :: pexp_tenv_tenv
	| G ( formula ) = ( tau , scope )  :: :: PrtckNm_TypeScope
	| G ( formula ) != ( tau , scope ) :: :: PrtckNm_not_TypeScope
        | G' = G [ formula -> ( tau , scope ) ] :: :: introduce_new_var
	| M ( P ) = ( argsig , { A1 , .. , Am } ) :: :: PrtclNm_ArgsigPartyNms
	| M ( P ) != ( argsig , { A1 , .. , Am } ) :: :: PrtclNm_not_ArgsigPartyNms
	| M' = M [ P -> ( argsig , { A1 , .. , Am } ) ] :: :: PrtclNm_ArgsigIntroduce
	| R ( P , A ) = portlist :: :: prtcl_party_TO_portlist
	| R ( P , A ) != portlist :: :: prtcl_party_notTO_portlist
	| R' = R [ ( P , A ) -> portlist ] :: :: prtcl_party_introduction
	| S ( s ) =  P :: :: sessionNm_PrtclNm
	| S ( s ) !=  P :: :: sessionNmNOT_PrtclNm
	| S' = S [ s -> P ] :: :: sessionNm_intro
	| L ( A , scope ) = portlist :: :: partynm_scopelist_TO_portlist
	| L ( A , scope ) != portlist :: :: partynm_scopelist_noTO_portlist
	| L' = L [ ( A , scope ) -> portlist ] :: :: partynm_scopelist_intro
	| P belongsto dom Tenv :: :: form_in_domain_fom
	| P notin dom Tenv :: :: form_notin_domain_fom
	| ( P , A ) belongsto dom Tenv :: :: prtclparty_in_domain_fom
	| A :: :: party_env
	| x :: :: var_env
	| P :: :: prtcl_env
	| scope :: :: scop
%------- Formulae for writing compilation semantics
  	| Cenv ( P , A , scope ) = O < scope' > :: :: prtcl_party_code_objectv
	| Cenv |- stmt , Cenv' :: :: comp_stmt
	| O < scope > comp_instr ( stmt ) :: :: crtstmt_in_codeObj 
	| O comp_instr ( stmt ) :: :: crtstm_in_currentcodeobj 
	| Cenv < scope > comp_instr ( comp_types1 portname1 , .. , comp_typesn portnamen ) : Cenv' :: :: crtcomptypePort_in_currentcodeobj 
	| Cenv < scope > comp_instr ( comp_types1 w1 , .. , comp_typesn wn )  : Cenv' :: :: crtcomptypeWire_in_currentcodeobj
	| Cenv < scope > comp_instr ( portname1 <-> w1 , .. , portnamen <-> wn ) :: :: atch_wire
	| Cenv < scope > comp_instr ( impl_instr ) : Cenv' :: :: writing_impl_inst
	| Cenv < scope > replace ( /* str */ ,  wstmt )  : Cenv' :: :: replace_str_with_code
	| Cenv < scope > replace ( /* str */ ,  O < A > )  : Cenv' :: :: replace_str_with_codeObj
	| P crt ( comp_types1 w1 , .. , comp_typesn wn ) :: :: createWire_inProtocol
	| E' = E [ ( scope , scope' , scope'' ) -> O < scope''' > ] :: :: populating_E
	| K' = K [ O < A >  -> { portname1 , .. , portnamen } ] :: :: populating_K
	| O < scope > copy O' < scope' > :: :: copy_code
	| K ( O < A > ) = { r_i , .. , r_j } :: :: get_portsFjromCodeObj
	| pexp = ( A , [ portname1 , portname2 ] ) :: :: portexpt_to_party_and_portlist
	

portname :: 'prtname' ::= {{ com Name of a port }}
	 | r :: :: port_r
	 | environ :: :: port_environ {{ tex \varepsilon }}
	 | scope . portname :: :: port_party_r
	 | A :: :: party {{ com Party can also be the name of a port }}
	 | x :: :: varnames

comp_instr :: 'CompInstr' ::= {{ com Compilation Instructions }}
     | crt :: :: create_something
     | apnd :: :: append_something
     | atch :: :: attach_wire_to_codeObject
     | copy :: :: copy_codeObject
     | impl_instr :: :: implemnt_instructions
     | replace :: :: replace_string {{ com Replace a temporary string with code }}

comp_types :: 'CompTypes' ::=
{{ com Compilation Types }}
     | Port :: :: port 
     | wire :: :: wire {{ tex \rhookrightarrow }}
       	    {{ com wire }}


impl_instr :: 'ImplInstr' ::= {{ com Instructions from the implementation language }}
	    | while ( impl_expr ) { /* str */ } :: :: whilestmt {{ com While statement }}
	    | if ( impl_expr ) { /* str */ } :: :: ifstmt {{ com If Statement }}
	    | x = read ( portname ) :: :: readport_tovar {{ com Read from a port }}
	    | portname = read ( x ) :: :: readvar_toport {{ com Read from a variable }}
	    | send x to A :: :: varToParty
	    | x = exp :: :: assign_exp_toVar
	    | read ( x ) :: :: read_value_of_var {{ com Read the value of a variable }}
	    | tau1 x1 , .. , taun xn :: :: create_new_var {{ com Create new variable }}
	    
impl_expr :: 'ImplExpr' ::= {{ com Expressions for the implementation language }}
	    | constant :: :: cnstnt {{ com Booleans like true or false }}
	    | portname :: :: prtname {{ com Portname }}
	    | portname . ITR :: :: prtintentToread {{ com Port intent to read }}
	    
% Type Checking rules ----------------------------------------------
defns
  Jtype :: '' ::= 
  
  % Type checking constants
  defn
	Tenv |- constant : tau :: ::  Constant :: Constant_ {{ com Checking constants }} by

	------------------------------ :: Int
	G , M , R , S , L , C|- integer_literal : Int

	------------------------------ :: true
	G , M , R , S , L , C|- true : Bool

	------------------------------ :: false
	G , M , R , S , L , C|- false : Bool
	
 % Type checking Statements
  defn 	Tenv |- stmt : tau , Tenv' :: :: Stmt :: Stmt_ by

  	     	G ( x ) != ( _ , C )
		G' = G [ x -> ( tau , C ) ]
		% TODO: see how we change R here
	------------------------------------------------------ :: decl
	G , M , R , S , L, C |- tau x ; : () , G' , M , R , S , L , C 

	G , M , R , S , L , _ |- statement : () , G' , M , R , S' , L'
	G' , M , R , S' , L' , _ |- statement' : () , G'' , M , R , S'' , L''
	----------------------------------------------------- :: seq
	G , M , R , S , L , _ |- statement ; statement' ; : () , G'' , M , R , S'' , L'' , _
		
	     G ( A1 ) = ( Party , _ )
	     G , M , R , S , L , A1 |- stmt1 : () , G' , M , R , S' , L'
	     G' , M , R , S' , L' , A1 |- stmtn : () , G'' , M , R , S'' , L''
	     G ( Am ) = ( Party , _ )
	     G'' , M , R , S'' , L'' , Am |- stmt1 : () , G''' , M , R , S''' , L'''
	     G''' , M , R , S''' , L''' , Am |- stmtn : () , G'''' , M , R , S'''' , L''''
	---------------------------------------------------------------------------------------- :: pvt
	G , M , R , S , L , C |- in each A1 , .. , Am { stmt1 , .. , stmtn } : () , G'''' , M , R , S'''' , L'''' , C 

	     G ( x ) = ( Int , C )
	 ------------------------------- :: sendEnvToVar
	    G , M , R , S , L , C |- env => x; : () , G , M , R , S , L , C 

	     G ( x ) = ( Int , C )
	 ------------------------------- :: sendVarToEnv
	    G , M , R , S , L , C |- x => env; : () , G , M , R , S , L , C 

	      G , M , R , S , L , C|- exp : tau
	      G , M , R , S , L , C|- exp' : tau'
	      tau belongsto { Port , Int , Bool , unknown }
	      tau' belongsto { Port , Int , Bool , unknown }
	 ---------------------------------------------------------------- :: sendExprToExpr
	      G , M , R , S , L , C|- exp => exp' : () , G , M , R , S , L , C 

	       G ( x ) = ( tau , C )
	       G , M , R , S , L , C |- exp : tau
	 ---------------------------------------------------------------- ::  assignmnt
	     G , M , R , S , L , C|- x = exp; : () , G , M , R , S , L , C 

	 G ( s ) = ( Session , C )
	 P belongsto dom M 
 	 M ( P ) = ( argsig , { A1 , .. , Am } )
	 G ( x1 ) = ( tau1 , C)
	 G ( xn ) = ( taun , C)
	 [ tau1 , .. , taun ] == argsig
	 G ( B1 ) = ( Party , C )
	 G ( Bm ) = ( Party , C )
	 S' = S [ s -> P ]
------------------------------------------------------------------------------------- :: openSession
 G , M , R , S , L , C|- open  s  as  P ( x1 , .. , xn ) { A1 : B1 , .. , Am : Bm } : () , G , M , R , S' , C 

	   G ( A ) = ( Party , C )
	   P belongsto dom M 
	   G ( x1 ) = ( tau1 , _ )
	   G ( xn ) = ( taun , _ )
	   M ( P ) = ( argsig , { A1 , .. , Am } )
	   B belongsto { A1 , .. , Am }
	   [ tau1 , .. , taun ] == argsig
	   ( P , B ) belongsto dom R
	   R ( P , B ) = portlist
	   L' = L [ ( A , C ) -> portlist ]
	 ------------------------------- :: set
	 G , M , R , S , L , C |- set A as P ( x1 , .. , xn )::B : () , G , M , R , S , L' , C 
         
	    G , M , R , S , L , C |- wstmt : () , G' , M , R , S' , L' 
	    G' , M , R , S' , L' , C |- wstmt : () , G'' , M , R , S'' , L'' 
	-------------------------------- :: wrap
	  G , M , R , S , L , C|- wrap { wstmt } : () , G'' , M , R , S'' , L'' , C 

	     	G , M , R , S , L , C|- pexp : Port
		G , M , R , S , L , C|- pexp' : Port
	---------------------------------------------- :: connectTo
        G , M , R , S , L , C|- connect pexp to pexp' : () , G , M , R , S , L , C 

	     	G , M , R , S , L , C|- pexp : Port
		G , M , R , S , L , C|- pexp' : Port
	---------------------------------------------- :: connectAnd
        G , M , R , S , L , C|- connect pexp and pexp' : () , G , M , R , S , L , C

	
defn Tenv |- wstmt : tau , Tenv' :: :: Wrapstmt :: Wrapstmt_ by

     	       G , M , R , S , L , C|- pexp : Port
	       G , M , R , S , L , C |- stmt1 : () , G' , M , R , S' , L' 
	       G' , M , R , S' , L' , C |- stmtn : () , G'' , M , R , S'' , L'' 
	    ---------------------------------------------- :: before
	G , M , R , S , L , C|- before pexp do { statement1 , .. , statementn } : () , G'' , M , R , S'' , L'' 

       	       G , M , R , S , L , C|- pexp : Port
	       G , M , R , S , L , C |- stmt1 : () , G' , M , R , S' , L' 
	       G' , M , R , S' , L' , C |- stmtn : () , G'' , M , R , S'' , L'' 
	---------------------------------------------- :: after
	G , M , R , S , L , C|- after pexp do { statement1 , .. , statementn } : () , G'' , M , R , S'' , L'' 

defn   Tenv |- prtcl : tau , Tenv' :: :: Protocol :: Prtcl_  by
  	       P notin dom M
	       G' = G [ P -> ( Protocol , W ) ]
	       G'' = G' [ x1 -> ( tau1 , W ) ]
	       G''' = G'' [ A -> ( Party , W ) ]
	       portlist = { x'1 , .. , x'i }
	       R' = R [ ( P , A ) -> portlist ]
	       M' = M [ P -> ( argsig , { A1 , .. , Am } ) ]
	       G''' , M' , R' , S , L |- prtcl' : () , G''' , M'' , R'' , S , L 
	       G''' , M'' , R'' , S , L , C |- stmt : () , G'''' , M'' , R''' , S''' , L'''
	----------------------------------------------- :: decl
	M , R |- protocol P ( tau1 x1 , .. , taun xn ( prtcl' ) ) : party A each with { Port x1' , .. , Port xi' } { stmt } : () , M'' , R''
	
defn	Tenv |- exp : tau :: :: Exp :: Exp_ by

		G , M , R , S , L , C|- exp : tau
		G , M , R , S , L , C|- exp' : tau
	--------------------------------------------- :: Addition
		G , M , R , S , L , C|- exp + exp' : tau


		G ( A ) = ( Party , C )
	        G ( x ) = ( Int , A )
		%tau belongsto { Int}
	--------------------------------------------- :: PartyVar
		G , M , R , S , L , C|- A . x : Int

	% 	G ( s ) = ( Session , _ )
	% 	S ( s ) = P
        %         M ( P ) = ( argsig , { A1 , .. , Am } )	
	% 	A belongsto { A1 , .. , Am }
	% --------------------------------------------- :: VarParty
	% 	G , M , R , S , L , C |- s . A : Party
		
		G ( x ) = ( tau , _ )
	--------------------------------------------- :: Statement
		G , M , R , S , L |- x : tau

defn Tenv |- pexp : tau :: :: Pexp :: Pexp_ by

     	  G ( s ) = ( Session , C )
	  S ( s ) = P
          M ( P ) = ( argsig , { A1 , .. , Am } )
	  A belongsto { A1 , .. , Am }
	  R ( P , A ) = portlist
	  r belongsto portlist
        ----------------------------------------------- :: ExpToEnv
     	  G , M , R , S , L , C |-  s . A I r : Port

                G ( A ) = ( Party , C )
		L ( A , C ) = portlist
		r belongsto portlist
	  ---------------------------------------------- :: PortOfParty
	  G , M , R , S , L , C |- A I r : Port

	    G ( A ) = ( Party , C )
	    L ( A , C ) = portlist
	    B belongsto portlist
	 ---------------------------------------------- :: PortOfAnotherParty
	 G , M , R , S , L , C |- A I B : Port
	  


{{ com
\section{Compilation Semantics}
\label{sec.comp}
The following rules define the compilation sematics of our language. Our language
first gets compiled to the following representation.
}}
% G , M , R , S , L , C |- 
% Opertional Semantics rules ----------------------------------------------
defns
  Jop :: '' ::=

  defn
	Cenv |- stmt : Cenv' :: ::  stmt_com :: Compl_
	{{ com Compiling Statements }} by

	     E ( P_c , A_1 , _ ) = O < A_1 >
	     E ( P_c , A_m , _ ) = O < A_m >
	     P_c , O < A_1 > |- stmt , O' < A_1 >
	     P_c , O < A_m > |- stmt , O' < A_m >
	-------------------------------------- :: inStmt
	E , P_c |- in each A_1 , .. , A_m { stmt } : E

	    O < D > crt ( tau x ; )
	------------------------------- :: decl
	O < D > |- tau x ; : O' < D >

	O < D > apnd ( x = read ( environ ) ) : O' < D > 
	------------------------------- :: PortToVar
	O < D > |- env => x ; : O' < D >

	O < D > apnd ( environ = read ( x ) ) : O' < D > 
	------------------------------- :: VarToPort
	O < D > |- x => env ; : O' < D >

	  O < A > apnd ( send x to B ) : O' < A >
	-------------------------------- :: ExpToExp
	O < A > |- A . x => B . y : O' < A >

	O < B > apnd ( y = read ( A ) ) : O' < B >
	-------------------------------- :: ExpToExp_1
	O < B > |- A . x => B . y : O' < B >

	O < D > apnd ( x = exp ) : O' < D >
	-------------------------------- :: assignment
  	O < D > |- x = exp ; : O' < D >
		
	    E ( P , B , _ ) = O < B >
	    E' = E [ ( P_c , A_c , D ) -> O < A_c > ]
	    O < B > copy O < A_c >
	    K_i ( O < B > ) = { r_1 , .. , r_j }
	    K_o ( O < B > ) = { r'_1 , .. , r'_j }
	    O < A_c > crt ( inport r_1 , .. , inport r_j  ) : O' < A_c >
	    O' < A_c > crt ( outport r'_1 , .. , outport r'_j  ) : O'' < A_c >
	    P_c crt ( wire w_1 , .. , wire w_j )
	    P_c crt ( wire w'_1 , .. , wire w'_j )
	    P_c crt ( wire w_e )
	    P_c crt ( wire w'_e )
	    O'' < A_c > crt ( inport A_c.r_1 , .. , inport A_c.r_j ) : O''' < A_c > 
	    O''' < A_c > crt ( outport A_c.r'_1 , .. , outport A_c.r'_j ) : O'''' < A_c > 
	    O'''' < A_c > crt ( inport A_c.environ , outport A_c.environ ) : O''''' < A_c > 
	    O''''' < A_c > atch ( environ <-> w_e )
	    O''''' < A_c > atch ( environ <-> w'_e )
	    O < D > atch ( A.environ <-> w_e )
	    O < D > atch ( A.environ <-> w'_e )
	    O''''' < A_c > atch ( r_1 <-> w_1 , .. , r_j <-> w_j )
	    O''''' < A_c > atch ( r'_1 <-> w'_1 , .. , r'_j <-> w'_j )
	    K_i' = K_i [ O < A > -> { r_1 , .. , r_j } ]
	    K_i'' = K_i' [ O < D > -> { r_1 , .. , r_j } ]	    
	    K_o' = K_o [ O < A > -> { r'_1 , .. , r'_j } ]	    
	    K_o'' = K_o' [ O < D > -> { r'_1 , .. , r'_j } ]	    
      --------------------------------------------------------------- :: set
	K_i , K_o , P_c , O < D > |- set A as P ( x1 , .. , xn )::B : E
	    
	    O < D > crt ( wire w_1 ) : O' < D >
	    O' < D > crt ( wire w_1' ) : O'' < D >
	    pexp = ( A , [ r_1 , r_1' ] ) 
	    pexp' = ( B , [ r_2 , r_2' ] )
	    O'' < D > atch ( A.r_1 <-> w_1 )  
	    O'' < D > atch ( B.r_2 <-> w_2 ) 
	    O'' < D > atch ( A.r_1' <-> w_1' ) 
	    O'' < D > atch ( B.r_2' <-> w_2' )
	------------------------------------------------------------ :: connect_and
	O < D > |- connect pexp and pexp' : O'' < D >

       	    O < D > crt ( wire w_1 ) : O' < D >
           pexp = ( A , [ r_1 , r_1' ] )
           pexp' = ( B , [ r_2 , r_2' ] )
	------------------------------------------------------------ ::  connect_to
	O < D > |- connect pexp to pexp' : E

	     E ( P_c , B , _ ) = O < B >
	     E ( P , A , _ ) = O < A >
	     E' = E [ ( P_c , s . A , D ) -> O < s  . A > ]
	     O < A > copy O < s . A >
	     O < B > crt ( inport s . A . environ ) : O' < B >
	     O < B > crt ( outport  s . A . environ ) : O' < B >
	     P_c crt ( wire w )
	     P'_c crt ( wire w' )
	------------------------------------------------------------- ::  opensession
	K, P_c , O < D > |- open  s  as  P ( x1 , .. , xn ) { A : B } : E

	    O < D > apnd ( while ( true ) { /* str */ } ) : O' < D >
	    O' < D > replace ( /* str */ , wstmt ) : O'' < D >
	------------------------------------------------------------- :: wrap
	    O < D > |- wrap { wstmt } : O'' < D >

defn
	Cenv |- exp : impl_instr :: ::  exp_com :: Compl_
	{{ com Compiling expressions }} by

	------------------------------------------------------ :: expstmt
	O < D > |- x : read ( x )
defn
	Cenv |- prtcl : Cenv' :: ::  prtcl_com :: Compl_
	{{ com Compiling Protocol }} by

	E' = E [ ( P , A_1 , _ ) -> O < A_1 > ]
	E'' = E' [ ( P , A_m , _ ) -> O < A_m > ]
	O < A_1 > crt ( tau1 x1 , .. , taun xn ) : O' < A_1 >
	O' < A_1 > crt ( Port1 y1 , .. , Porti yi ) : O'' < A_1 >
	O < A_1 > crt ( Port A2 , .. , Port Am ) : O < A_1 >
	O < A_1 > crt ( Port environ ) : O < A_1 >
	O < A_m > crt ( tau1 x1 , .. , taun xn ) : O' < A_m >
	O' < A_m > crt ( Port1 y1 , .. , Porti yi ) : O'' < A_m >
	O < A_m > crt ( Port A2 , .. , Port Am ) : O < A_m >
	O < A_m > crt ( Port environ ) : O < A_m >
	P crt ( wire w1 )
	O < A_1 > atch ( A2 <-> w1 )
	------------------------------------------------------- :: prtcl
	O < D > |- protocol P ( tau1 x1 , .. , taun xn ( prtcl' ) ) : party A each with { Port1 y1 , .. , Porti yi } { stmt } : O' < D > 
defn
	Cenv |- wstmt : Cenv' :: ::  wstmt_com :: Compl_
	{{ com Compiling statements inside wrap }} by

	    pexp = ( A , [ r_1 , r_1'] )
	    E' = E [ ( _ , _ , _ ) -> O < Z > ]
    	    E' = E [ ( _ , _ , _ ) -> O < Z' > ]
	    O < Z > apnd ( if ( A . r . ITR ) { /* str */ } ) : O' < Z >
	    O < Z' > |- stmt1 : O' < Z' >
	    O' < Z' > |- stmtn : O'' < Z' >
	    O' < Z > replace ( /* str */ , O'' < Z' > ) : O'' < Z >
	------------------------------------------------------------- :: before
	  O < D > |- before pexp do { statement1 , .. , statementn } : O'' < Z >

  	    pexp = ( A , [ r_1 , r_1'] )
	    E' = E [ ( _ , _ , _ ) -> O < A > ]
	------------------------------------------------------------- :: after
	  O < D > |- after pexp do { statement1 , .. , statementn } : O < Z >

